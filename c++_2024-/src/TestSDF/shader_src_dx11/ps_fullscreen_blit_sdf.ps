cbuffer BlitSDF : register(b0) {
    float4 viewMatrix0;
    float4 viewMatrix1;
    float4 viewMatrix2;
    float4 viewMatrix3;
    float4 proj_row2;
    float tanfov; float aspect; float near; float far;
    float time; float platformSize; float2 padding;
}

struct VertexOut {
    float2 uv : TEXCOORD0;
    float4 positionCS : SV_POSITION;
};
struct PS_OUT
{
    float4 color : SV_Target;
    float depth : SV_Depth;
};

float sdSphere( float3 p, float s )
{
  return length(p)-s;
}

float sdBox( float3 p, float3 b ) {
  float3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sdCone( float3 p, float2 c, float h )
{
  float q = length(p.xz);
  return max(dot(c.xy,float2(q,p.y)),-h-p.y);
}

float sdThickDisk( float3 p, float3 n, in float r, in float thick )  
{
    float3 d = dot(p, n) * n;
    float3 o = p - d;
    o -= normalize( o ) * min( length( o ), r );
    return length( d + o ) - thick;
}

float2 sdBird(float3 pos) {

    float t = frac(0.7*time);
    
    float y = 0.7 + 0.2 * t * (1.0 - t);
    float3 center = float3(0.0, y, 0.0);
    float3 q = pos - center;
    
    // head
    float3 head = q - float3(-0.027, 0.685, 0.0);
    float d = sdSphere(head, 0.409);
    float2 res = float2(d, 2.0);
    
    // eyes
    float3 headSymm = float3(head.xy, abs(head.z));
    float d1 = sdSphere(headSymm - float3(0.0, 0.0, 0.2), 0.262);
    if (d1 < res.x) { res.y = 3.0; }
    d1 = sdSphere(headSymm - float3(0.0, 0.0, 0.35), 0.098);
    if (d1 < res.x) { res.y = 4.0; }
    
    // beak
    float3 cone = q - float3(0.77, 0.4, 0.0);
    cone.xy = mul(float2x2(-2, -6, 6, -2)/6.3245,cone.xy);
    float d2 = sdCone(cone, float2(0.6, 0.25), 0.528);
    if (d2 < res.x) { res = float2(d2, 5.0); }
    
    // body
    float d3 = sdBox(q - float3(-0.012, 0.01, 0), float3(0.123, 0.214, 0.14));
    if (d3 < res.x) { res = float2(d3, 6.0); }
    d3 = sdBox(q - float3(0.002, -0.1, 0), float3(0.203, 0.031, 0.203));
    if (d3 < res.x) { res.y = 7.0; }
    
    float3 bodySymm = float3(q.xy, abs(q.z));
    
    // arms
    float angle = -0.1 - 0.5 * t * (1.0 - t);
    //float angle = -0.2 - 0.15 * t;
    float sa = sin(angle);
    float ca = cos(angle);
    float3 u = float3(1.0, 0.0, 0.0);
    float3 v = float3(0.0, ca, sa);
    float3 w = float3(0.0, -sa, ca);
    float3 arms = bodySymm - float3(-0.012, 0.235, 0.21);
    float3 armsrot = float3(dot(arms,u), dot(arms,v), dot(arms,w));
    float3 armsextents = float3(0.034, 0.23, 0.028);
    float d4 = sdBox(armsrot + armsextents, armsextents); // rotation pivot at origin
    if (d4 < res.x) { res = float2(d4, 2.0); }
    
    // legs
    d4 = sdBox(bodySymm - float3(-0.012, -0.43, 0.1), float3(0.034, 0.18, 0.028));
    if (d4 < res.x) { res = float2(d4, 2.0); }
    
    return res;
}


float2 map(float3 pos) {

    pos.yz = float2(pos.z, -pos.y);

    // character
    float3 scaledPos = 0.35 * pos;
    float2 d1 = sdBird(scaledPos);

    // platform
    float d2 = sdThickDisk(pos - float3(0.0, 0.0, 0.0), float3(0.0, 1.0, 0.0), platformSize, 0.286);
    float2 res = (d2 < d1.x) ? float2(d2, 1.0) : d1;

    return res;
}

float3 calcNormal(float3 pos) {
    float2 e = float2(0.0001, 0.0);
    return normalize(float3(map(pos+e.xyy).x-map(pos-e.xyy).x,
                            map(pos+e.yxy).x-map(pos-e.yxy).x,
                            map(pos+e.yyx).x-map(pos-e.yyx).x));
                              
}

float castShadow(float3 ro, float3 rd) {
    float res = 1.0;
    float t = 0.001;
    for (int i = 0; i < 100; i++) {
    
        float3 pos = ro + t * rd;
        float h = map(pos).x;
        
        res = min(res, 20.0 * h/t);
        if (res < 0.0001) break;
        t += h;
        
        if (t > 20.0) { t = -1.0; break; }
    }
    return clamp(res, 0.0, 1.0);
}

float2 castRay(float3 ro, float3 rd) {
    float t = 0.01;
    float m = -1.0;
    for (int i = 0; i < 250; i++) {
    
        float3 pos = ro + t * rd;
        
        float2 hm = map(pos);
        if (hm.x < 0.001) break; // inside object
    
        t += hm.x;
        m = hm.y;
        if (t > far) { m = -1.0; break; }
    }
    return float2(t,m);
}

float3 nearPos_WS(float2 uv) {
    // uv space ((0,0) top left, (1,1) bottom right) to NDC space ((0,0) center, y up, x right)
    float2 pos_NDC = uv * float2(2.0, -2.0) + float2(-1,1);
    // NDC to eye space (right handed, y up, z front)
    float4 pos_ES = float4(pos_NDC.x * aspect * tanfov, pos_NDC.y * tanfov, -1.f, 1.f / near);
    pos_ES = pos_ES / pos_ES.w;
    // to world space (right handed, z up)
    pos_ES.xyz = pos_ES.xyz - viewMatrix3.xyz;
    float3 pos_WS = float3(dot(viewMatrix0.xyz, pos_ES.xyz), dot(viewMatrix1.xyz, pos_ES.xyz), dot(viewMatrix2.xyz, pos_ES.xyz));
    
    return pos_WS;
}

PS_OUT PS(VertexOut IN) {

    // camera	
    float3 camPos_WS = float3(
        -dot(viewMatrix0.xyz, viewMatrix3.xyz),
        -dot(viewMatrix1.xyz, viewMatrix3.xyz),
        -dot(viewMatrix2.xyz, viewMatrix3.xyz));
    float3 ro = camPos_WS;
    float3 camToNear_WS = nearPos_WS(IN.uv) - camPos_WS;
    float3 rd = normalize(camToNear_WS);
    
    
    // raymarch scene
    float2 tm = castRay(ro, rd);
    
    PS_OUT output;
    output.depth = 1.0;
    output.color = float4(0.0, 0.0, 0.0, 0.0);
    if (tm.y > 0.0) {
        float3 pos = ro + tm.x * rd;
        float3 normal = calcNormal(pos);
        
        // query materials
        float3 mate = float3(1.0, 1.0, 1.0);
        if (tm.y > 6.5) {
            mate = mate * float3(1.0, 1.0, 1.0);
        } else if (tm.y > 5.5) {
            mate = mate * float3(1.0, 0.592, 1.0);
        } else if (tm.y > 4.5) {
            mate = mate * float3(1.0, 1.0, 0.33);
        } else if (tm.y > 3.5) {
            mate = mate * float3(0.05, 0.05, 0.05);
        } else if (tm.y > 2.5) {
            mate = mate * float3(0.79, 0.79, 0.79);
        } else if (tm.y > 1.5) {
            mate = mate * float3(0.1, 0.1, 0.1);
        } else /* if (tm.y > 0.5)*/ {
            mate = mate * float3(0.05, 0.09, 0.02);
        }

        // compute lighting
        float3 sun_dir = normalize(float3(sin(time), cos(time), 0.87));
        float sun_dif = clamp(dot(normal, sun_dir), 0.0, 1.0);
        float sun_sha = castShadow(pos + normal * 0.001, sun_dir);
        float sky_dif = clamp(0.5 + dot(normal, float3(0.0, 0.0, 1.0)), 0.0, 1.0);
        float bounce_dif = clamp(0.3 + 0.5 * dot(normal, float3(0.0, -1.0, 0.0)), 0.0, 1.0);
        float3 col = mate * 0.7*float3(7.0, 5.5, 4.0) * sun_dif * sun_sha;
        col += mate *  0.7*float3(0.7, 0.4, 1.1) * sky_dif;
        col += mate *  0.7*float3(0.18, 0.23, 0.17) * bounce_dif;
   
        // gamma correction
        col = pow(col, float3(0.4545, 0.4545, 0.4545));

        output.color = float4(col.xyz, 1.0 );

        // compute depth

        // project intersection position's z and w coordinate to clip space and perform perspective
        // divide, so we can extract the z component and write to the depth buffer
        float4 vpMatrix_row2 = float4(
            dot(proj_row2, viewMatrix0),
            dot(proj_row2, viewMatrix1),
            dot(proj_row2, viewMatrix2),
            dot(proj_row2, viewMatrix3));
        float4 vpMatrix_row3 = float4(  // todo: this assumes that proj_row3 is (0, 0, -1, 0),
            -viewMatrix0.z,             // but I think I'm sort of ok with that
            -viewMatrix1.z,
            -viewMatrix2.z,
            -viewMatrix3.z);
        float pos_CS_z = dot(vpMatrix_row2, float4(pos, 1.0));
        float pos_CS_w = dot(vpMatrix_row3, float4(pos, 1.0));
        float depth = pos_CS_z / pos_CS_w;

        // alternatively, if we want to pass the whole vp matrix
        //float zc = ( mul(vpMatrix, float4( pos, 1.0 )) ).z;
        //float wc = ( mul(vpMatrix, float4( pos, 1.0 )) ).w;
        //float depth = zc / wc;

        output.depth = depth;
    }

    return output;
}